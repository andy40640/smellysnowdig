<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Smelly's snow dig</title>
  <style>
    :root { --ui: rgba(255,255,255,.92); --shadow: rgba(0,0,0,.25); }
    html, body { height: 100%; margin: 0; overflow: hidden; font-family: system-ui, -apple-system, "Segoe UI", Arial, "Noto Sans TC", sans-serif; }
    #app { position: relative; width: 100%; height: 100%; background: #0b1320; }
    /* Start screen */
    #startScreen {
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
    }
    #startBg {
      position:absolute; inset:-40px;
      background: url("./ËÉåÊôØ.png") center/cover no-repeat;
      filter: blur(12px) brightness(0.95) saturate(1.05);
      transform: scale(1.08);
    }
    #startShade {
      position:absolute; inset:0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,.15), rgba(0,0,0,.45));
    }
    #titleWrap {
      position:absolute; left:50%; top:12%;
      transform: translateX(-50%);
      width:min(700px, 90vw);
      display:flex; justify-content:center;
      pointer-events:none;
    }
    #titleImg { width:100%; height:auto; filter: drop-shadow(0 10px 18px rgba(0,0,0,.35)); }
    #startBtnWrap {
      position:absolute; left:50%; bottom:12%;
      transform: translateX(-50%) scale(0.7);
      transform-origin: center;
      cursor:pointer;
      user-select:none;
      filter: drop-shadow(0 12px 16px rgba(0,0,0,.35));
      transition: transform .12s ease;
    }
    #startBtnWrap:active { transform: translateX(-50%) scale(0.66); }
    #startBtn { width:min(520px, 80vw); height:auto; display:block; }
    #hint {
      position:absolute; left:50%; bottom:5%;
      transform: translateX(-50%);
      color: rgba(255,255,255,.9);
      font-size: 14px;
      letter-spacing:.3px;
      text-shadow: 0 2px 10px rgba(0,0,0,.55);
      opacity:.95;
      pointer-events:none;
    }

    /* Game screen */
    #gameScreen { position:absolute; inset:0; display:none; }
    #gameCanvas { position:absolute; inset:0; width:100%; height:100%; }
    #topToast {
      position:absolute; left:50%; top:12px; transform: translateX(-50%);
      padding: 10px 14px; border-radius: 14px;
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.92);
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 20px rgba(0,0,0,.18);
      font-size: 14px;
      pointer-events:none;
      opacity:0;
      transition: opacity .25s ease;
      max-width: min(680px, 92vw);
      text-align:center;
      line-height: 1.3;
    }

    /* Reward popup */
    #popup {
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.35);
      
    }
    #popupCard {
      position: relative;
      width: min(900px, 92vw);
      max-height: 88vh;
      display:flex;
      align-items:center; justify-content:center;
      padding: 14px;
    }
    #popupImg {
      box-shadow: none !important;
      filter: none !important;

      max-width: 100%;
      max-height: 84vh;
      height:auto; width:auto;
      border-radius: 18px;
      background: rgba(255,255,255,.02);
    }
    #popupTip {
      position:absolute; left:50%; bottom:-4px;
      transform: translateX(-50%);
      color: rgba(255,255,255,.9);
      font-size: 13px;
      text-shadow: 0 2px 10px rgba(0,0,0,.55);
      opacity:.95;
      pointer-events:none;
      white-space: nowrap;
    }

    /* Small help */
    #muteBtn{
      position:absolute; right:12px; top:12px;
      border:none; border-radius: 14px;
      padding: 10px 12px;
      background: rgba(0,0,0,.35);
      color: rgba(255,255,255,.9);
      backdrop-filter: blur(6px);
      cursor:pointer;
      box-shadow: 0 10px 20px rgba(0,0,0,.18);
      font-size: 13px;
    }
    #muteBtn:active { transform: translateY(1px); }
  
canvas{touch-action:none;user-select:none;-webkit-user-select:none;overscroll-behavior:none;}
</style>
</head>
<body>
  <div id="app">
    <div id="startScreen" aria-label="start screen">
      <div id="startBg"></div>
      <div id="startShade"></div>

      <div id="titleWrap">
        <img id="titleImg" src="./title3.png" alt="title">
      </div>

      <div id="startBtnWrap" title="Start">
        <img id="startBtn" src="./start3.png" alt="start">
      </div>

      <div id="hint">Èªû‰∏Ä‰∏ã Start ÈñãÂßãÊåñÂØ∂ÔºàÂª∫Ë≠∞ÈñãËÅ≤Èü≥ üéÑÔºâ</div>
    </div>

    <div id="gameScreen" aria-label="game screen">
      <canvas id="gameCanvas"></canvas>
      <div id="topToast"></div>
      <button id="muteBtn">üîä Èü≥Ê®ÇÔºöÈñã</button>

      <div id="popup">
        <div id="popupCard">
          <img id="popupImg" src="" alt="reward">
          <div id="popupTip" style="display:none"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // Asset loading
  // =========================
  const assets = {
    bg: "./ËÉåÊôØ.png",
    start: "./start3.png",
    title: "./title3.png",
    stand: "./‰∫∫2.png",   // idle
    dig: "./‰∫∫1.png",     // digging
    run: "./‰∫∫3.png",     // moving
    kiss: "./kiss3.png",
    hug: "./hug3.png",
    punch: "./punch3.png",
    voucher: "./ÁôªÂ±±Áî®ÂìÅÂà∏.png",
    hole: "./hole2.png",
  };

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  const IMG = {};
  async function loadAll() {
    const keys = Object.keys(assets);
    await Promise.all(keys.map(async k => { IMG[k] = await loadImage(assets[k]); }));
  }

  // =========================
  // WebAudio: Christmas-ish BGM + canned SFX
  // =========================
  let audioCtx = null;
  let bgmOn = true;
  let bgmTimer = null;
  let masterGain = null;

  function ensureAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.8;
      masterGain.connect(audioCtx.destination);
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  function beep(freq, t, dur, type="triangle", gain=0.12) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t);

    // envelope
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

    o.connect(g);
    g.connect(masterGain);

    o.start(t);
    o.stop(t + dur + 0.02);
  }

  function noiseBurst(t, dur, gain=0.12, hp=800, lp=6000) {
    if (!audioCtx) return;
    const bufferSize = Math.max(1, Math.floor(audioCtx.sampleRate * dur));
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);

    const src = audioCtx.createBufferSource();
    src.buffer = buffer;

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t + 0.005);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

    const hpf = audioCtx.createBiquadFilter(); hpf.type = "highpass"; hpf.frequency.setValueAtTime(hp, t);
    const lpf = audioCtx.createBiquadFilter(); lpf.type = "lowpass";  lpf.frequency.setValueAtTime(lp, t);

    src.connect(hpf); hpf.connect(lpf); lpf.connect(g); g.connect(masterGain);
    src.start(t);
    src.stop(t + dur + 0.02);
  }

  // Simple festive melody (Jingle Bells-ish feel, not exact)
  // Notes in Hz
  const N = {
    C4:261.63, D4:293.66, E4:329.63, F4:349.23, G4:392.00, A4:440.00, B4:493.88,
    C5:523.25, D5:587.33, E5:659.25
  };

  // A short loop pattern (approximate, original-ish)
  const melody = [
    [N.E5, 0.18], [N.E5, 0.18], [N.E5, 0.28],
    [N.E5, 0.18], [N.E5, 0.18], [N.E5, 0.28],
    [N.E5, 0.18], [N.G5=783.99, 0.18], [N.C5, 0.18], [N.D5, 0.18], [N.E5, 0.38],
    [N.F5=698.46, 0.18], [N.F5, 0.18], [N.F5, 0.18], [N.F5, 0.18], [N.F5, 0.18],
    [N.E5, 0.18], [N.E5, 0.18], [N.E5, 0.18], [N.E5, 0.18],
    [N.D5, 0.18], [N.D5, 0.18], [N.E5, 0.18], [N.D5, 0.28], [N.G5, 0.34],
  ];

  function startBGM() {
    if (!bgmOn) return;
    ensureAudio();
    stopBGM();
    const t0 = audioCtx.currentTime + 0.05;
    let t = t0;

    // light bell pad
    const pad = audioCtx.createOscillator();
    const padGain = audioCtx.createGain();
    pad.type = "sine";
    pad.frequency.setValueAtTime(220, t0);
    padGain.gain.setValueAtTime(0.0, t0);
    padGain.gain.linearRampToValueAtTime(0.05, t0 + 0.4);
    padGain.gain.linearRampToValueAtTime(0.02, t0 + 4.0);
    pad.connect(padGain);
    padGain.connect(masterGain);
    pad.start(t0);

    // schedule melody
    for (const [f, d] of melody) {
      beep(f, t, d * 0.98, "triangle", 0.09);
      // tiny sparkle
      if (Math.random() < 0.35) beep(f*2, t + 0.02, 0.06, "sine", 0.025);
      t += d;
    }

    const loopLen = t - t0;
    bgmTimer = window.setTimeout(() => {
      try { pad.stop(); } catch(e){}
      startBGM();
    }, Math.max(100, Math.floor(loopLen * 1000)));

    // stop pad after loop
    window.setTimeout(() => { try { pad.stop(); } catch(e){} }, Math.floor(loopLen * 1000) + 50);
  }

  function stopBGM() {
    if (bgmTimer) { clearTimeout(bgmTimer); bgmTimer = null; }
  }

  // SFX
  function sfxFootstep() {
    ensureAudio();
    const t = audioCtx.currentTime;
    // canned-ish: short filtered noise + tiny click
    noiseBurst(t, 0.06, 0.08, 400, 2400);
    beep(120, t, 0.05, "square", 0.03);
  }
  function sfxDig() {
    ensureAudio();
    const t = audioCtx.currentTime;
    noiseBurst(t, 0.10, 0.16, 250, 4500);
    noiseBurst(t + 0.07, 0.08, 0.12, 250, 4500);
    beep(180, t, 0.08, "square", 0.035);
  }
  function sfxBell() {
    ensureAudio();
    const t = audioCtx.currentTime;
    // jingle: multiple partials
    beep(880, t, 0.35, "sine", 0.10);
    beep(1320, t + 0.02, 0.28, "sine", 0.06);
    beep(1760, t + 0.04, 0.22, "sine", 0.045);
    beep(990, t + 0.08, 0.20, "triangle", 0.04);
  }

  // =========================
  // Game setup
  // =========================
  const startScreen = document.getElementById("startScreen");
  const startBtnWrap = document.getElementById("startBtnWrap");
  const gameScreen  = document.getElementById("gameScreen");
  const canvas      = document.getElementById("gameCanvas");
  const ctx         = canvas.getContext("2d");
  const toast       = document.getElementById("topToast");
  const popup       = document.getElementById("popup");
  const popupImg    = document.getElementById("popupImg");
  const muteBtn     = document.getElementById("muteBtn");

  const DPR = () => Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));

  function resize() {
    canvas.width  = Math.floor(window.innerWidth * DPR());
    canvas.height = Math.floor(window.innerHeight * DPR());
  }
  window.addEventListener("resize", resize);

  function showToast(msg, ms=1200) {
    toast.textContent = msg;
    toast.style.opacity = 1;
    window.setTimeout(() => toast.style.opacity = 0, ms);
  }

  // Dig spots: 35 distributed in central "safe" region
  // We'll use an ellipse region centered, to avoid edges where trees/house likely are.
  let spots = []; // {x,y,type,dug,showing}
  const TYPES = ["empty","kiss","hug","punch","grand"];

  function genSpots(w, h) {
    spots = [];
    const cx = w * 0.50, cy = h * 0.56;
    const rx = w * 0.33, ry = h * 0.30;

    function insideEllipse(x,y){
      const dx = (x-cx)/rx, dy = (y-cy)/ry;
      return (dx*dx + dy*dy) <= 1.0;
    }

    // Poisson-ish sampling by rejection with min distance
    const target = 35;
    const minDist = Math.min(w, h) * 0.06;
    let tries = 0;
    while (spots.length < target && tries < 12000) {
      tries++;
      const x = cx + (Math.random()*2-1) * rx;
      const y = cy + (Math.random()*2-1) * ry;
      if (!insideEllipse(x,y)) continue;

      let ok = true;
      for (const s of spots) {
        const dx = s.x - x, dy = s.y - y;
        if (dx*dx + dy*dy < minDist*minDist) { ok = false; break; }
      }
      if (!ok) continue;
      spots.push({x, y, type:"empty", dug:false, showing:false});
    }

    // Assign rewards
    const idx = [...Array(spots.length).keys()];
    for (let i = idx.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [idx[i], idx[j]] = [idx[j], idx[i]];
    }
    const pick = (n, type) => { for (let k=0;k<n;k++) spots[idx.shift()].type = type; };
    pick(1, "grand");
    pick(5, "kiss");
    pick(5, "hug");
    pick(5, "punch");
    // rest stay empty
  }

  // Player state
  const player = {
    x: 0, y: 0,
    tx: 0, ty: 0,
    state: "idle", // idle | move | dig
    facing: 1,     // 1 right, -1 left
    t: 0,
    scale: 0.10,   // requested size 1/10
    stepTimer: 0
  };

  function resetPlayer(w,h){
    player.x = w*0.18;
    player.y = h*0.72;
    player.tx = player.x;
    player.ty = player.y;
    player.state = "idle";
    player.t = 0;
    player.facing = 1;
    player.stepTimer = 0;
  }

  // Helper: find nearest spot clicked (within radius)
  function pickSpot(x,y){
    let best = null;
    const r = Math.min(canvas.width, canvas.height) * 0.06;
    const rr = r*r;
    for (const s of spots) {
      const dx = s.x - x, dy = s.y - y;
      const d2 = dx*dx + dy*dy;
      if (d2 < rr && (!s.dug)) {
        if (!best || d2 < best.d2) best = {s, d2};
      }
    }
    return best ? best.s : null;
  }

  // Drawing
  function drawBackground(){
    // draw background image covering canvas
    const w = canvas.width, h = canvas.height;
    const img = IMG.bg;
    const iw = img.width, ih = img.height;

    const scale = Math.max(w/iw, h/ih);
    const dw = iw*scale, dh = ih*scale;
    const dx = (w - dw)/2, dy = (h - dh)/2;

    ctx.drawImage(img, dx, dy, dw, dh);

    // subtle snowfall overlay
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#ffffff";
    for (let i=0;i<120;i++){
      const x = (Math.sin((player.t*0.35)+i)*0.5+0.5)*w;
      const y = ((player.t*0.7+i*19)%1)*h;
      const r = (i%5+1) * DPR();
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  
  
  function drawHole(s){
    const img = IMG.hole;
    const size = Math.min(canvas.width, canvas.height) * 0.06;
    ctx.drawImage(img, s.x - size/2, s.y - size/2, size, size);
  }



  function drawSpots(){
    // We don't show undiscovered points. Only show holes after dug.
    for (const s of spots) if (s.dug) drawHole(s);
  }

  
  function drawPlayer(){
    const w = canvas.width, h = canvas.height;
    let img = IMG.stand;
    if (player.state === "dig") img = IMG.dig;
    else if (player.state === "move") img = IMG.run;

    const base = Math.min(w, h);
    const scale = player.scale * (base / 900);
    const dw = img.width * scale * DPR();
    const dh = img.height * scale * DPR();

    let bob = 0;
    let rot = 0;
    if (player.state === "move") {
      bob = Math.sin(player.t*16) * 3*DPR();
    }
    if (player.state === "dig") {
      bob = Math.sin(player.t*24) * 2*DPR();
      rot = Math.sin(player.t*32) * 0.06;
    }

    ctx.save();
    ctx.translate(player.x, player.y + bob);

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(0, dh*0.44, dw*0.20, dh*0.07, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.rotate(rot);
    ctx.scale(player.facing, 1);
    ctx.drawImage(img, -dw/2, -dh*0.85, dw, dh);
    ctx.restore();
  }


  function worldToCanvas(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * DPR();
    const y = (clientY - rect.top) * DPR();
    return {x, y};
  }

  // =========================
  // Game loop
  // =========================
  let last = 0;
  let movingTo = null; // spot
  let diggingSpot = null;
  let digEndAt = 0;

  function update(dt){
    player.t += dt;

    if (player.state === "move" && movingTo) {
      const dx = movingTo.x - player.x;
      const dy = movingTo.y - player.y;
      player.facing = (dx >= 0) ? 1 : -1;

      const dist = Math.hypot(dx, dy);
      const speed = Math.min(canvas.width, canvas.height) * 0.45; // px/sec
      const step = speed * dt;

      // footsteps
      player.stepTimer -= dt;
      if (player.stepTimer <= 0) {
        sfxFootstep();
        player.stepTimer = 0.22;
      }

      if (dist <= step) {
        player.x = movingTo.x;
        player.y = movingTo.y;
        player.state = "dig";
        diggingSpot = movingTo;
        movingTo = null;
        player.stepTimer = 0;

        sfxDig();
        digEndAt = performance.now() + 750;
      } else {
        player.x += (dx / dist) * step;
        player.y += (dy / dist) * step;
      }
    }

    if (player.state === "dig") {
      if (performance.now() >= digEndAt && diggingSpot) {
        diggingSpot.dug = true;
        handleReward(diggingSpot);
        diggingSpot = null;
        player.state = "idle";
      }
    }
  }

  
  // ===============================
  // Jackpot FX (sparkles + particles)
  let jackpotActive = false;
  let particles = [];
  let sparkleT = 0;

  function startJackpotFX(){
    jackpotActive = true;
    particles = [];
    sparkleT = 0;
    // burst
    for(let i=0;i<80;i++){
      particles.push(makeParticle());
    }
  }
  function stopJackpotFX(){
    jackpotActive = false;
    particles = [];
  }
  function makeParticle(){
    const cx = canvas.width*0.5, cy = canvas.height*0.2;
    const a = Math.random()*Math.PI*2;
    const sp = 1.5 + Math.random()*3.5;
    return {
      x: cx + (Math.random()*60-30),
      y: cy + (Math.random()*40-20),
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp - (1.5+Math.random()*2.5),
      life: 0.6 + Math.random()*0.9,
      age: 0,
      size: 1.5 + Math.random()*3.5,
      rot: Math.random()*Math.PI*2
    };
  }
  function updateJackpotFX(dt){
    if(!jackpotActive) return;
    sparkleT += dt;
    // continuous emit
    for(let i=0;i<5;i++){
      if(particles.length<220) particles.push(makeParticle());
    }
    // update
    for(const p of particles){
      p.age += dt;
      p.vy += 9.2*dt; // gravity
      p.x += p.vx;
      p.y += p.vy;
      p.rot += dt*6.0;
    }
    particles = particles.filter(p=>p.age<p.life && p.y<canvas.height+50);
  }
  function drawJackpotFX(){
    if(!jackpotActive) return;
    const t = sparkleT;

    // soft glow behind popup area
    ctx.save();
    ctx.globalAlpha = 0.35 + 0.15*Math.sin(t*3.2);
    ctx.fillStyle = "#fff3a6";
    ctx.beginPath();
    ctx.ellipse(canvas.width*0.5, canvas.height*0.20, canvas.width*0.18, canvas.height*0.09, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // particles (stars)
    ctx.save();
    for(const p of particles){
      const a = 1 - (p.age/p.life);
      ctx.globalAlpha = a;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      drawStar(0,0,p.size, p.size*0.45, 5);
      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();

    // sparkles around popup
    const s = 6 + 2*Math.sin(t*7.0);
    sparkle(canvas.width*0.38, canvas.height*0.16, s);
    sparkle(canvas.width*0.62, canvas.height*0.17, s*0.9);
    sparkle(canvas.width*0.50, canvas.height*0.11, s*0.7);
  }

  function drawStar(x,y,r,ir,pts){
    ctx.beginPath();
    for(let i=0;i<pts*2;i++){
      const ang = i*Math.PI/pts;
      const rr = (i%2===0)? r: ir;
      ctx.lineTo(x+Math.cos(ang)*rr, y+Math.sin(ang)*rr);
    }
    ctx.closePath();
    ctx.fillStyle = "#ffd24d";
    ctx.fill();
  }
  function sparkle(x,y,s){
    ctx.save();
    ctx.globalAlpha = 0.75;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x-s, y); ctx.lineTo(x+s, y);
    ctx.moveTo(x, y-s); ctx.lineTo(x, y+s);
    ctx.stroke();
    ctx.restore();
  }

function render(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();
    
    if (popup && popup.type === "voucher") drawJackpotFX();
drawSpots();
    drawPlayer();
  }

  function loop(ts){
    if (!last) last = ts;
    const dt = Math.min(0.04, (ts - last) / 1000);
    last = ts;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // =========================
  // Rewards
  // =========================
  let popupOpen = false;

  function openPopup(src, isGrand=false){
    popupImg.src = src;
    popup.style.display = "flex";
    popupOpen = true;
    if (isGrand) {
      } else {
      }
  }

  function closePopup(){
    stopJackpotFX();
    try{ if(bellLoop){ bellLoop.pause(); bellLoop.currentTime = 0; } }catch(e){}

    popup.style.display = "none";
    popupOpen = false;
  }

  popup.addEventListener("click", () => closePopup());

  function handleReward(spot){
    if (spot.type === "kiss") {
      showToast("ÊåñÂà∞ÔºöMao's kiss * 1 üòò");
      openPopup(assets.kiss);
    } else if (spot.type === "hug") {
      showToast("ÊåñÂà∞ÔºöMao's hug * 1 ü§ó");
      openPopup(assets.hug);
    } else if (spot.type === "punch") {
      showToast("ÊåñÂà∞ÔºöMao's punch * 1 üëä");
      openPopup(assets.punch);
    } else if (spot.type === "grand") {
      showToast("üéâ ‰Ω†ÊåñÂà∞ÊúÄÂ§ßÁçéÔºöÁôªÂ±±Áî®ÂìÅÊäµÁî®Âà∏ÔºÅ", 1600);
      sfxBell();
      openPopup(assets.voucher, true);
    } else {
      // empty
      const msgs = ["Á©∫ÁöÑÔºÅÂÜç‰æÜÔΩû", "Âè™ÊúâÈõ™ÔΩû", "ÈÄôÊ¥ûÊ≤íÊù±Ë•øQQ", "‰∏ã‰∏ÄÂÄã‰∏ÄÂÆöÊúâÔºÅ"];
      showToast(msgs[(Math.random()*msgs.length)|0]);
    }
  }

  // =========================
  // Input: click to dig
  // =========================
  canvas.addEventListener("pointerdown", (e) => {
    if (popupOpen) return;
    if (player.state !== "idle") return;

    const {x, y} = worldToCanvas(e.clientX, e.clientY);
    const s = pickSpot(x, y);
    if (!s) {
      showToast("‰∏≠ÈñìÈõ™Âú∞ÊâçÊúâÈªû‰ΩçÂñîÔΩû", 900);
      return;
    }
    movingTo = s;
    player.state = "move";
    player.stepTimer = 0.01;
  });

  // =========================
  // Start flow
  // =========================
  muteBtn.addEventListener("click", () => {
    bgmOn = !bgmOn;
    muteBtn.textContent = bgmOn ? "üîä Èü≥Ê®ÇÔºöÈñã" : "üîá Èü≥Ê®ÇÔºöÈóú";
    if (bgmOn) startBGM(); else stopBGM();
  });

  async function startGame() {
    startScreen.style.display = "none";
    gameScreen.style.display = "block";

    resize();

    // initialize world
    genSpots(canvas.width, canvas.height);
    resetPlayer(canvas.width, canvas.height);

    showToast("Èªû‰∏≠ÈñìÈõ™Âú∞ÊåñÂØ∂ÔºÅÊåñÂà∞ÂúñÊ°àÊôÇÂÜçÈªû‰∏Ä‰∏ãÈóúÊéâÔΩû", 1800);

    requestAnimationFrame(loop);
  }

  startBtnWrap.addEventListener("click", async () => {
    try {
      await loadAll();
    } catch (e) {
      alert("ÂúñÁâáËºâÂÖ•Â§±ÊïóÔºåË´ãÁ¢∫Ë™çÂêåË≥áÊñôÂ§æÊúâÔºöËÉåÊôØ.png„ÄÅ‰∫∫1.png„ÄÅ‰∫∫2.png„ÄÅ‰∫∫3.png„ÄÅstart3.png„ÄÅtitle3.png„ÄÅkiss3.png„ÄÅhug3.png„ÄÅpunch3.png„ÄÅÁôªÂ±±Áî®ÂìÅÂà∏.png");
      console.error(e);
      return;
    }

    // audio must start after user gesture
    ensureAudio();
    bgmOn = true;
    muteBtn.textContent = "üîä Èü≥Ê®ÇÔºöÈñã";
    startBGM();

    startGame();
  });

})();
</script>
</body>
</html>
